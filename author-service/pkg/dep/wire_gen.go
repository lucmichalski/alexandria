// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package dep

import (
	"context"
	zipkin2 "contrib.go.opencensus.io/exporter/zipkin"
	"github.com/alexandria-oss/core/config"
	"github.com/alexandria-oss/core/logger"
	"github.com/alexandria-oss/core/tracer"
	"github.com/alexandria-oss/core/transport"
	"github.com/alexandria-oss/core/transport/proxy"
	"github.com/go-kit/kit/log"
	"github.com/google/wire"
	"github.com/maestre3d/alexandria/author-service/internal/dependency"
	"github.com/maestre3d/alexandria/author-service/pkg/author"
	"github.com/maestre3d/alexandria/author-service/pkg/author/usecase"
	"github.com/maestre3d/alexandria/author-service/pkg/transport/bind"
	"github.com/openzipkin/zipkin-go"
	"github.com/openzipkin/zipkin-go/model"
	"github.com/openzipkin/zipkin-go/reporter"
	"github.com/openzipkin/zipkin-go/reporter/http"
	"go.opencensus.io/trace"
)

// Injectors from wire.go:

func InjectTransportService() (*transport.Transport, func(), error) {
	logLogger := logger.NewZapLogger()
	authorInteractor, cleanup, err := provideAuthorInteractor(logLogger)
	if err != nil {
		return nil, nil, err
	}
	context := provideContext()
	kernel, err := config.NewKernel(context)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	reporter := provideZipkinReporter(kernel)
	endpoint := provideZipkinEndpoint(kernel)
	zipkinTracer, cleanup2 := provideZipkinTracer(reporter, endpoint)
	opentracingTracer := tracer.WrapZipkinOpenTracing(kernel, zipkinTracer)
	authorRPCServer := bind.NewAuthorRPC(authorInteractor, logLogger, opentracingTracer, zipkinTracer)
	healthRPCServer := bind.NewHealthRPC()
	v := provideRPCServers(authorRPCServer, healthRPCServer)
	server, cleanup3 := proxy.NewRPC(v)
	authorHandler := bind.NewAuthorHTTP(authorInteractor, logLogger, opentracingTracer, zipkinTracer)
	v2 := provideHTTPHandlers(authorHandler)
	http, cleanup4 := proxy.NewHTTP(kernel, v2...)
	authorSAGAInteractor, cleanup5, err := provideAuthorSAGAInteractor(logLogger)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	authorEventConsumer := bind.NewAuthorEventConsumer(authorSAGAInteractor, logLogger)
	v3 := provideEventConsumers(authorEventConsumer)
	event, cleanup6, err := proxy.NewEvent(context, kernel, v3...)
	if err != nil {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	transportTransport := transport.NewTransport(server, http, event, kernel)
	return transportTransport, func() {
		cleanup6()
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

var Ctx = context.Background()

var authorInteractorSet = wire.NewSet(logger.NewZapLogger, provideAuthorInteractor)

var zipkinSet = wire.NewSet(
	provideZipkinReporter,
	provideZipkinEndpoint,
	provideZipkinTracer,
)

var httpProxySet = wire.NewSet(
	authorInteractorSet,
	provideContext, config.NewKernel, zipkinSet, tracer.WrapZipkinOpenTracing, bind.NewAuthorHTTP, provideHTTPHandlers, proxy.NewHTTP,
)

var rpcProxySet = wire.NewSet(bind.NewAuthorRPC, bind.NewHealthRPC, provideRPCServers, proxy.NewRPC)

var eventProxySet = wire.NewSet(
	provideAuthorSAGAInteractor, bind.NewAuthorEventConsumer, provideEventConsumers, proxy.NewEvent,
)

func provideContext() context.Context {
	return Ctx
}

func provideAuthorInteractor(logger2 log.Logger) (usecase.AuthorInteractor, func(), error) {
	dependency.Ctx = Ctx
	authorUseCase, cleanup, err := dependency.InjectAuthorUseCase()

	authorService := author.WrapAuthorInstrumentation(authorUseCase, logger2)

	return authorService, cleanup, err
}

func provideAuthorSAGAInteractor(logger2 log.Logger) (usecase.AuthorSAGAInteractor, func(), error) {
	dependency.Ctx = Ctx
	authorUseCase, cleanup, err := dependency.InjectAuthorSAGAUseCase()

	authorService := author.WrapAuthorSAGAInstrumentation(authorUseCase, logger2)

	return authorService, cleanup, err
}

// Bind/Map used http handlers
func provideHTTPHandlers(authorHandler *bind.AuthorHandler) []proxy.Handler {
	handlers := make([]proxy.Handler, 0)
	handlers = append(handlers, authorHandler)
	return handlers
}

// Bind/Map used rpc servers
func provideRPCServers(authorServer *bind.AuthorRPCServer, healthServer *bind.HealthRPCServer) []proxy.RPCServer {
	servers := make([]proxy.RPCServer, 0)
	servers = append(servers, authorServer)
	servers = append(servers, healthServer)
	return servers
}

func provideEventConsumers(authorHandler *bind.AuthorEventConsumer) []proxy.Consumer {
	consumers := make([]proxy.Consumer, 0)
	consumers = append(consumers, authorHandler)
	return consumers
}

// NewZipkin returns a zipkin tracing consumer
func provideZipkinReporter(cfg *config.Kernel) reporter.Reporter {
	if cfg.Tracing.ZipkinHost != "" {
		zipkinReporter := http.NewReporter(cfg.Tracing.ZipkinHost)
		return zipkinReporter
	}

	return nil
}

// NewZipkin returns a zipkin tracing consumer
func provideZipkinEndpoint(cfg *config.Kernel) *model.Endpoint {
	if cfg.Tracing.ZipkinEndpoint != "" {
		zipkinEndpoint, err := zipkin.NewEndpoint(cfg.Service, cfg.Tracing.ZipkinEndpoint)
		if err != nil {
			return nil
		}

		return zipkinEndpoint
	}

	return nil
}

// NewZipkin returns a zipkin tracing consumer
func provideZipkinTracer(r reporter.Reporter, ep *model.Endpoint) (*zipkin.Tracer, func()) {
	if r != nil && ep != nil {
		trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})
		trace.RegisterExporter(zipkin2.NewExporter(r, ep))

		zipkinTrace, err := zipkin.NewTracer(r, zipkin.WithLocalEndpoint(ep))
		if err != nil {
			return nil, nil
		}
		cleanup := func() {
			_ = r.Close()
		}

		return zipkinTrace, cleanup
	}

	return nil, nil
}
